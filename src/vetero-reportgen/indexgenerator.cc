/* {{{
 * (c) 2011, Bernhard Walle <bernhard@bwalle.de>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>. }}}
 */

#include <iostream>
#include <cstdlib>

#include <libbw/stringutil.h>
#include <common/utils.h>

#include "calendar.h"
#include "indexgenerator.h"
#include "htmldocument.h"

namespace vetero {
namespace reportgen {

// -------------------------------------------------------------------------------------------------
IndexGenerator::IndexGenerator(VeteroReportgen *reportGenerator)
    : ReportGenerator(reportGenerator)
{}

// -------------------------------------------------------------------------------------------------
void IndexGenerator::generateReports()
    throw (common::ApplicationError)
{
    HtmlDocument html(reportgen());
    html.setTitle("Ãœbersicht Wetterdaten");
    html.setDisplayTitle(false);

    html.addSection("Aktuelle Wetterdaten", "Aktuell", "current");
    html << "<a href='" << bw::Datetime::now().dateStr() << ".xhtml'>";
    html.img("current_weather.svg"); // generated by the CurrentReportGenerator
    html << "</a>\n";

    try {
        int minYear, maxYear;
        getYearRange(minYear, maxYear);

        for (int year = maxYear; year >= minYear; --year) {
            std::string yearStr = bw::str(year);
            html.addSection(yearStr, yearStr, yearStr);

            generateYear(html, year);
            html.addTopLink();
        }
    } catch (const common::DatabaseError &err) {
        throw common::ApplicationError("DB error: " + std::string(err.what()));
    }

    std::string indexHtml = reportgen()->configuration().getReportDirectory() + "/index.xhtml";
    if (!html.write(indexHtml))
        throw common::ApplicationError("Unable to write " + indexHtml);
}

// -------------------------------------------------------------------------------------------------
void IndexGenerator::generateYear(HtmlDocument &html, int year)
{
    const int ROWS = 3, COLUMNS = 4;

    html << "<table>";
    for (int row = 0; row < ROWS; row++) {
        html << "<tr>\n";

        for (int col = 1; col <= COLUMNS; col++) {
            int month = (row * COLUMNS) + col;
            html << "<td>";
            generateMonth(html, year, month);
            html << "</td>";
        }

        html << "</tr>\n";
    }
    html << "</table>\n";
}

// -------------------------------------------------------------------------------------------------
void IndexGenerator::generateMonth(HtmlDocument &html, int year, int month)
{
    int numDataDaysInMonth = dataInMonth(year, month);

    std::string monthString;
    if (numDataDaysInMonth > 0)
        monthString = "<a href=\"" + common::str_printf("%04d-%02d.xhtml", year, month) + "\">" +
                      Calendar::monthName(month) + "</a>";
    else
        monthString = Calendar::monthName(month);


    html << "<table style=\"border:thin solid black;border-spacing:5px\" >\n"
         << "<tr>\n"
         << "  <td colspan=\"7\" align=\"center\"><b><big>" << monthString << "</big></b></td>\n"
         << "</tr>\n";

    // day names
    html << "<tr>\n";
    for (int wday = 1; wday <= 7; wday++)
        html << "<td align=\"center\"><b>" << Calendar::dayAbbreviation(wday) << "</b></td>\n";
    html << "</tr>\n";

    // first weekday
    int weekdayOfFirst = bw::Datetime(year, month, 1, 0, 0, 0, false).weekday();
    int currentDay = 1;
    int lastDay = Calendar::daysPerMonth(year, month);
    for (int line = 0; line < 6; line++) {
        html << "<tr>\n";

        for (int wday = 1; wday <= 7; wday++) {
            std::string dayString = "&nbsp;";

            if (!(currentDay == 1 && wday < weekdayOfFirst) && (currentDay <= lastDay)) {
                if (numDataDaysInMonth == lastDay || (numDataDaysInMonth > 0 && dataAtDay(year, month, currentDay)))
                    dayString = "<a href=\"" + common::str_printf("%04d-%02d-%02d.xhtml", year, month, currentDay) +
                                "\">" + bw::str(currentDay) + "</a>";
                else
                    dayString = bw::str(currentDay);
                currentDay++;

            }
            html << "<td align=\"right\">" << dayString << "</td>";
        }

        html << "</tr>\n";
    }

    html << "</table>";
}

// -------------------------------------------------------------------------------------------------
bool IndexGenerator::dataAtDay(int year, int month, int day)
{
    std::string dayStr = common::str_printf("%04d-%02d-%02d", year, month, day);

    common::Database::DbResultVector result = reportgen()->database().executeSqlQuery(
            "SELECT COUNT(*) "
            "FROM   weatherdata "
            "WHERE  date(timestamp) = date(?, 'localtime')", dayStr.c_str());

    int count = std::atoi(result.at(0).at(0).c_str());

    return count > 0;
}

// -------------------------------------------------------------------------------------------------
int IndexGenerator::dataInMonth(int year, int month)
{
    std::string monthStr = common::str_printf("%04d-%02d-", year, month);
    std::string firstDay = monthStr + "01";
    std::string lastDay = monthStr + bw::str(Calendar::daysPerMonth(year, month));

    common::Database::DbResultVector result = reportgen()->database().executeSqlQuery(
            "SELECT COUNT(DISTINCT(date(timestamp))) "
            "FROM   weatherdata "
            "WHERE  date(timestamp) BETWEEN date(?, 'localtime') AND date(?, 'localtime')",
            firstDay.c_str(), lastDay.c_str());

    return std::atoi(result.at(0).at(0).c_str());
}

// -------------------------------------------------------------------------------------------------
void IndexGenerator::getYearRange(int &firstYear, int &lastYear)
{
    common::Database::DbResultVector result = reportgen()->database().executeSqlQuery(
            "SELECT strftime('%%Y', datetime(MIN(timestamp), 'utc')), "
            "       strftime('%%Y', datetime(MAX(timestamp), 'utc')) "
            "FROM   weatherdata");

    firstYear = std::atoi(result.at(0).at(0).c_str());
    lastYear = std::atoi(result.at(0).at(1).c_str());
}

} // end namespace reportgen
} // end namespace vetero
