/* {{{
 * (c) 2011, Bernhard Walle <bernhard@bwalle.de>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>. }}}
 */

#include <iostream>
#include <cstdlib>

#include <libbw/stringutil.h>
#include <libbw/log/debug.h>

#include "common/utils.h"
#include "common/translation.h"
#include "calendar.h"
#include "indexgenerator.h"
#include "htmldocument.h"

namespace vetero {
namespace reportgen {

// -------------------------------------------------------------------------------------------------
IndexGenerator::IndexGenerator(VeteroReportgen *reportGenerator)
    : ReportGenerator(reportGenerator)
    , m_dbAccess(&reportGenerator->database())
{}

// -------------------------------------------------------------------------------------------------
void IndexGenerator::generateReports()
    throw (common::ApplicationError)
{
    BW_DEBUG_INFO("Generating index");

    HtmlDocument html(reportgen());
    html.setAutoReload(5);
    html.setTitle(_("Overview Weather data"));
    html.setDisplayTitle(false);

    html.addSection( _("Current weather data"), _("Current"), "current");
    html << "<a href='" << bw::Datetime::now().dateStr() << ".xhtml'>";
    html.img("current_weather.svgz"); // generated by the CurrentReportGenerator
    html << "</a>\n";

    try {
        std::vector<std::string> dataYears = m_dbAccess.dataYears();

        std::vector<std::string>::const_iterator it;
        for (it = dataYears.begin(); it != dataYears.end(); ++it) {
            std::string year = *it;
            html.addSection(year, year, year);

            generateYear(html, bw::from_str<int>(year));
            html.addTopLink();
        }
    } catch (const common::DatabaseError &err) {
        throw common::ApplicationError("DB error: " + std::string(err.what()));
    }

    std::string indexHtml = reportgen()->configuration().reportDirectory() + "/index.xhtml";
    if (!html.write(indexHtml))
        throw common::ApplicationError("Unable to write " + indexHtml);
}

// -------------------------------------------------------------------------------------------------
void IndexGenerator::generateYear(HtmlDocument &html, int year)
{
    BW_DEBUG_TRACE("Index: Generate year %d", year);

    const int ROWS = 3, COLUMNS = 4;

    html << "<table>";
    for (int row = 0; row < ROWS; row++) {
        html << "<tr>\n";

        for (int col = 1; col <= COLUMNS; col++) {
            int month = (row * COLUMNS) + col;
            html << "<td>";
            generateMonth(html, year, month);
            html << "</td>";
        }

        html << "</tr>\n";
    }
    html << "</table>\n";
}

// -------------------------------------------------------------------------------------------------
void IndexGenerator::generateMonth(HtmlDocument &html, int year, int month)
{
    BW_DEBUG_TRACE("Index: Generate month %d-%02d", year, month);

    const ValidDataCache &dataCache = reportgen()->validDataCache();
    std::string monthString;
    bool haveData = dataCache.dataInMonth(year, month);

    html << "<table style=\"border:thin solid black;border-spacing:5px\" >\n"
         << "<tr>\n"
         << "  <td colspan=\"7\" align=\"center\"><b><big>";

    html.link(common::str_printf("%04d-%02d.xhtml", year, month),
              Calendar::monthName(month), haveData);

    html << "</big></b></td>\n"
         << "</tr>\n";

    // day names
    html << "<tr>\n";
    for (int wday = 1; wday <= 7; wday++) {
        html << "<td align=\"center\"><b>";
        html.text(Calendar::dayAbbreviation(wday), haveData);
        html << "</b></td>\n";
    }
    html << "</tr>\n";

    // first weekday
    int weekdayOfFirst = bw::Datetime(year, month, 1, 0, 0, 0, false).weekday();
    int currentDay = 1;
    int lastDay = Calendar::daysPerMonth(year, month);
    for (int line = 0; line < 6; line++) {
        html << "<tr>\n";

        for (int wday = 1; wday <= 7; wday++) {

            html << "<td align='right'>";

            if (!(currentDay == 1 && wday < weekdayOfFirst) && (currentDay <= lastDay)) {
                bool active = haveData && dataCache.dataAtDay(year, month, currentDay);
                html.link(common::str_printf("%04d-%02d-%02d.xhtml", year, month, currentDay),
                          bw::str(currentDay), active);
                currentDay++;
            } else
                html << "&nbsp;";

            html << "</td>\n";
        }

        html << "</tr>\n";
    }

    html << "</table>";
}


} // end namespace reportgen
} // end namespace vetero
